<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xanthorox Agent - Advanced DDoS Control Panel</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            border: 2px solid #00ff88;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.05) 100%);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.4), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #00ff88, 0 0 40px rgba(0, 255, 136, 0.5);
            letter-spacing: 2px;
            font-weight: 300;
        }
        
        .subtitle {
            font-size: 1.3em;
            color: #00cc66;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        .status-active {
            background-color: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }
        
        .status-inactive {
            background-color: #ff4444;
            box-shadow: 0 0 10px #ff4444;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .progress-container {
            margin-bottom: 30px;
            position: relative;
        }
        
        .progress-bar {
            width: 100%;
            height: 25px;
            background: linear-gradient(90deg, #1a1a2e 0%, #0a0a0a 100%);
            border: 2px solid #00ff88;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88 0%, #00cc66 100%);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 13px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progress-shimmer 2s infinite;
        }
        
        @keyframes progress-shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 0.9em;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .panel {
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 25px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 255, 136, 0.02) 100%);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 255, 136, 0.3);
            border-color: #00ffaa;
        }
        
        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, #00ff88, #00ffaa, #00ff88);
            animation: border-glow 2s infinite;
        }
        
        @keyframes border-glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .panel h2 {
            margin-bottom: 20px;
            font-size: 1.6em;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel h2 i {
            font-size: 0.8em;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #00ff88;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.8) 0%, rgba(10, 10, 10, 0.9) 100%);
            border: 2px solid #00ff88;
            border-radius: 10px;
            color: #00ff88;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.95em;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00ffaa;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4), inset 0 2px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        
        button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #0a0a0a;
            border: 2px solid #00ff88;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            font-size: 1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            margin: 5px;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            background: linear-gradient(135deg, #00ffaa 0%, #00ff88 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.4);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #444 0%, #333 100%);
            border-color: #555;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff4444 0%, #cc0000 100%);
            border-color: #ff4444;
        }
        
        .btn-danger:hover {
            background: linear-gradient(135deg, #ff6666 0%, #ff4444 100%);
            box-shadow: 0 8px 20px rgba(255, 68, 68, 0.4);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 255, 136, 0.05) 100%);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(0, 255, 136, 0.3);
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            color: #00ff88;
        }
        
        .stat-label {
            font-size: 1em;
            color: #00cc66;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .log-container {
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 255, 136, 0.02) 100%);
            backdrop-filter: blur(10px);
            height: 350px;
            overflow-y: auto;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.2);
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid #00ff88;
            background: rgba(0, 255, 136, 0.05);
            transition: all 0.3s ease;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .log-entry:hover {
            background: rgba(0, 255, 136, 0.1);
            transform: translateX(5px);
        }
        
        .log-info {
            border-left-color: #00ff88;
        }
        
        .log-error {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, 0.05);
            color: #ff8888;
        }
        
        .log-warning {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.05);
            color: #ffdd88;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            background: rgba(0, 255, 136, 0.05);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            transition: all 0.3s ease;
        }
        
        .checkbox-item:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: #00ff88;
            transform: translateY(-2px);
        }
        
        .checkbox-item input {
            width: auto;
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .checkbox-item label {
            margin: 0;
            font-weight: 500;
            cursor: pointer;
        }
        
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        .advanced-toggle {
            background: linear-gradient(135deg, #ff8800 0%, #ff6600 100%);
            border-color: #ff8800;
            position: relative;
        }
        
        .advanced-toggle:hover {
            background: linear-gradient(135deg, #ffaa00 0%, #ff8800 100%);
            box-shadow: 0 8px 20px rgba(255, 136, 0, 0.4);
        }
        
        .performance-meter {
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, #1a1a2e 0%, #0a0a0a 100%);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .performance-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ff8800 50%, #00ff88 100%);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.9) 0%, rgba(0, 255, 136, 0.8) 100%);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px 20px;
            color: #0a0a0a;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4);
            z-index: 1000;
            animation: slideIn 0.5s ease;
            max-width: 300px;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .chart-container {
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.05) 0%, rgba(0, 255, 136, 0.02) 100%);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.2);
            margin-bottom: 30px;
        }
        
        .chart-container h2 {
            margin-bottom: 15px;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .checkbox-group {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>XANTHOROX AGENT</h1>
            <p class="subtitle">Advanced DDoS Control Panel <span class="status-indicator status-inactive" id="statusIndicator"></span></p>
        </header>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar">
                    <div class="progress-text" id="progressText">0%</div>
                </div>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="requestsCount">0</div>
                <div class="stat-label">Requests</div>
                <div class="performance-meter">
                    <div class="performance-fill" id="requestsMeter"></div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="errorsCount">0</div>
                <div class="stat-label">Errors</div>
                <div class="performance-meter">
                    <div class="performance-fill" id="errorsMeter"></div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bytesCount">0</div>
                <div class="stat-label">Bytes Sent</div>
                <div class="performance-meter">
                    <div class="performance-fill" id="bytesMeter"></div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="rpsCount">0</div>
                <div class="stat-label">RPS</div>
                <div class="performance-meter">
                    <div class="performance-fill" id="rpsMeter"></div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="successCount">0</div>
                <div class="stat-label">Success</div>
                <div class="performance-meter">
                    <div class="performance-fill" id="successMeter"></div>
                </div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="failedCount">0</div>
                <div class="stat-label">Failed</div>
                <div class="performance-meter">
                    <div class="performance-fill" id="failedMeter"></div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="panel">
                    <h2><i class="fas fa-target"></i> Target Configuration</h2>
                    <div class="form-group">
                        <label for="targetUrl">Target URL:</label>
                        <input type="text" id="targetUrl" placeholder="http://example.com">
                    </div>
                    <div class="form-group">
                        <label for="targetPort">Target Port:</label>
                        <input type="number" id="targetPort" value="80">
                    </div>
                    <div class="form-group">
                        <label for="threads">Threads:</label>
                        <input type="number" id="threads" value="4">
                    </div>
                    <div class="form-group">
                        <label for="duration">Duration (seconds):</label>
                        <input type="number" id="duration" value="60">
                    </div>
                    <div class="form-group">
                        <label for="payloadSize">Payload Size (bytes):</label>
                        <input type="number" id="payloadSize" value="1024">
                    </div>
                </div>
                
                <div class="panel">
                    <h2><i class="fas fa-sliders-h"></i> Attack Options</h2>
                    <div class="form-group">
                        <label>HTTP Methods:</label>
                        <div class="checkbox-group">
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodGET" checked>
                                <label for="methodGET">GET</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodPOST" checked>
                                <label for="methodPOST">POST</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodHEAD" checked>
                                <label for="methodHEAD">HEAD</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodOPTIONS" checked>
                                <label for="methodOPTIONS">OPTIONS</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodPUT">
                                <label for="methodPUT">PUT</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodDELETE">
                                <label for="methodDELETE">DELETE</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="methodPATCH">
                                <label for="methodPATCH">PATCH</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="panel">
                    <h2><i class="fas fa-network-wired"></i> Attack Vectors</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="httpFlood" checked>
                            <label for="httpFlood">HTTP Flood</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="tcpFlood" checked>
                            <label for="tcpFlood">TCP Flood</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="udpFlood" checked>
                            <label for="udpFlood">UDP Flood</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="slowloris" checked>
                            <label for="slowloris">Slowloris</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="dnsAmp">
                            <label for="dnsAmp">DNS Amplification</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="memcachedAmp">
                            <label for="memcachedAmp">Memcached Amplification</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="ntpAmp">
                            <label for="ntpAmp">NTP Amplification</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="websocketFlood">
                            <label for="websocketFlood">WebSocket Flood</label>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2><i class="fas fa-shield-alt"></i> Bypass Options</h2>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="cloudflareBypass" checked>
                            <label for="cloudflareBypass">Cloudflare Bypass</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="randomHeaders" checked>
                            <label for="randomHeaders">Random Headers</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="randomPayload" checked>
                            <label for="randomPayload">Random Payload</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="amplification" checked>
                            <label for="amplification">Amplification</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chart-container">
            <h2><i class="fas fa-chart-line"></i> Real-time Performance</h2>
            <canvas id="performanceChart" width="800" height="300" style="width: 100%; height: 300px; background: rgba(0, 255, 136, 0.05); border-radius: 10px;"></canvas>
        </div>
        
        <div class="log-container" id="logContainer">
            <div class="log-entry log-info">
                <i class="fas fa-info-circle"></i> [Xanthorox Agent] Advanced Control Panel Initialized
            </div>
            <div class="log-entry log-info">
                <i class="fas fa-check-circle"></i> [Xanthorox Agent] All systems operational
            </div>
            <div class="log-entry log-info">
                <i class="fas fa-rocket"></i> [Xanthorox Agent] Ready for deployment
            </div>
        </div>
        
        <div class="control-panel">
            <button id="startAttack" onclick="startAttack()">
                <i class="fas fa-play"></i> Start Attack
            </button>
            <button id="stopAttack" class="btn-danger" onclick="stopAttack()" disabled>
                <i class="fas fa-stop"></i> Stop Attack
            </button>
            <button onclick="resetStats()">
                <i class="fas fa-redo"></i> Reset Stats
            </button>
            <button onclick="exportConfig()">
                <i class="fas fa-download"></i> Export Config
            </button>
            <button onclick="importConfig()">
                <i class="fas fa-upload"></i> Import Config
            </button>
            <button class="advanced-toggle" onclick="toggleAdvancedMode()">
                <i class="fas fa-magic"></i> Advanced Mode
            </button>
            <input type="file" id="configFile" style="display: none;" accept=".json">
        </div>
    </div>
    
    <script>
        // Global variables
        let isAttacking = false;
        let attackStartTime = null;
        let statsInterval = null;
        let progressInterval = null;
        let statusInterval = null;
        let currentAttackId = null;
        let performanceData = {
            labels: [],
            requests: [],
            errors: [],
            rps: []
        };
        let chartContext = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeChart();
            addLogEntry('[Xanthorox Agent] Advanced Control Panel Initialized', 'info');
            addLogEntry('[Xanthorox Agent] All systems operational', 'info');
            addLogEntry('[Xanthorox Agent] Ready for deployment', 'info');
        });
        
        // Initialize performance chart
        function initializeChart() {
            const canvas = document.getElementById('performanceChart');
            if (!canvas) return;
            
            chartContext = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 300;
            
            // Draw initial chart
            drawChart();
        }
        
        // Draw performance chart
        function drawChart() {
            if (!chartContext) return;
            
            const canvas = chartContext.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            chartContext.clearRect(0, 0, width, height);
            
            // Draw grid
            chartContext.strokeStyle = 'rgba(0, 255, 136, 0.2)';
            chartContext.lineWidth = 1;
            
            for (let i = 0; i <= 10; i++) {
                const y = (height / 10) * i;
                chartContext.beginPath();
                chartContext.moveTo(0, y);
                chartContext.lineTo(width, y);
                chartContext.stroke();
            }
            
            // Draw data
            if (performanceData.labels.length > 1) {
                const maxValue = Math.max(...performanceData.requests, ...performanceData.errors, ...performanceData.rps);
                const xScale = width / (performanceData.labels.length - 1);
                const yScale = (height - 40) / maxValue;
                
                // Draw requests line
                chartContext.strokeStyle = '#00ff88';
                chartContext.lineWidth = 2;
                chartContext.beginPath();
                performanceData.requests.forEach((value, index) => {
                    const x = index * xScale;
                    const y = height - (value * yScale) - 20;
                    if (index === 0) {
                        chartContext.moveTo(x, y);
                    } else {
                        chartContext.lineTo(x, y);
                    }
                });
                chartContext.stroke();
                
                // Draw errors line
                chartContext.strokeStyle = '#ff4444';
                chartContext.lineWidth = 2;
                chartContext.beginPath();
                performanceData.errors.forEach((value, index) => {
                    const x = index * xScale;
                    const y = height - (value * yScale) - 20;
                    if (index === 0) {
                        chartContext.moveTo(x, y);
                    } else {
                        chartContext.lineTo(x, y);
                    }
                });
                chartContext.stroke();
                
                // Draw RPS line
                chartContext.strokeStyle = '#ff8800';
                chartContext.lineWidth = 2;
                chartContext.beginPath();
                performanceData.rps.forEach((value, index) => {
                    const x = index * xScale;
                    const y = height - (value * yScale) - 20;
                    if (index === 0) {
                        chartContext.moveTo(x, y);
                    } else {
                        chartContext.lineTo(x, y);
                    }
                });
                chartContext.stroke();
            }
        }
        
        // Update performance meters
        function updatePerformanceMeters(stats) {
            const maxRequests = 10000;
            const maxErrors = 1000;
            const maxBytes = 1000000;
            const maxRPS = 1000;
            const maxSuccess = 10000;
            const maxFailed = 1000;
            
            document.getElementById('requestsMeter').style.width = `${Math.min(100, (stats.requests / maxRequests) * 100)}%`;
            document.getElementById('errorsMeter').style.width = `${Math.min(100, (stats.errors / maxErrors) * 100)}%`;
            document.getElementById('bytesMeter').style.width = `${Math.min(100, (stats.bytes / maxBytes) * 100)}%`;
            document.getElementById('rpsMeter').style.width = `${Math.min(100, (stats.rps / maxRPS) * 100)}%`;
            document.getElementById('successMeter').style.width = `${Math.min(100, (stats.successfulConnections / maxSuccess) * 100)}%`;
            document.getElementById('failedMeter').style.width = `${Math.min(100, (stats.failedConnections / maxFailed) * 100)}%`;
        }
        
        // Add log entry
        function addLogEntry(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            let icon = 'fa-info-circle';
            if (type === 'error') icon = 'fa-exclamation-triangle';
            if (type === 'warning') icon = 'fa-exclamation-circle';
            
            logEntry.innerHTML = `<i class="fas ${icon}"></i> [${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Format bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Update stats display
        function updateStats(stats) {
            const safeStats = {
                requests: stats.requests || 0,
                errors: stats.errors || 0,
                bytes: stats.bytes || 0,
                rps: stats.rps || 0,
                successfulConnections: stats.successfulConnections || 0,
                failedConnections: stats.failedConnections || 0
            };
            
            document.getElementById('requestsCount').textContent = safeStats.requests.toLocaleString();
            document.getElementById('errorsCount').textContent = safeStats.errors.toLocaleString();
            document.getElementById('bytesCount').textContent = formatBytes(safeStats.bytes);
            document.getElementById('rpsCount').textContent = safeStats.rps.toLocaleString();
            document.getElementById('successCount').textContent = safeStats.successfulConnections.toLocaleString();
            document.getElementById('failedCount').textContent = safeStats.failedConnections.toLocaleString();
            
            // Update performance meters
            updatePerformanceMeters(safeStats);
            
            // Update chart data
            const now = new Date();
            performanceData.labels.push(now.toLocaleTimeString());
            performanceData.requests.push(safeStats.requests);
            performanceData.errors.push(safeStats.errors);
            performanceData.rps.push(safeStats.rps);
            
            // Keep only last 20 data points
            if (performanceData.labels.length > 20) {
                performanceData.labels.shift();
                performanceData.requests.shift();
                performanceData.errors.shift();
                performanceData.rps.shift();
            }
            
            // Redraw chart
            drawChart();
        }
        
        // Function to monitor attack status
        function startStatusMonitoring(attackId) {
            statusInterval = setInterval(() => {
                fetch(`/api/attack/${attackId}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.status === 'stopped') {
                        stopAttack();
                        addLogEntry('Attack completed successfully', 'info');
                        showNotification('Attack Completed', 'success');
                    }
                })
                .catch(error => {
                    console.error('Error monitoring attack:', error);
                });
            }, 2000);
        }
        
        // Get attack configuration
        function getAttackConfig() {
            const methods = [];
            if (document.getElementById('methodGET').checked) methods.push('GET');
            if (document.getElementById('methodPOST').checked) methods.push('POST');
            if (document.getElementById('methodHEAD').checked) methods.push('HEAD');
            if (document.getElementById('methodOPTIONS').checked) methods.push('OPTIONS');
            if (document.getElementById('methodPUT').checked) methods.push('PUT');
            if (document.getElementById('methodDELETE').checked) methods.push('DELETE');
            if (document.getElementById('methodPATCH').checked) methods.push('PATCH');
            
            const hasAdvancedOptions = 
                document.getElementById('dnsAmp').checked ||
                document.getElementById('memcachedAmp').checked ||
                document.getElementById('ntpAmp').checked ||
                document.getElementById('websocketFlood').checked;
            
            return {
                target: document.getElementById('targetUrl').value,
                port: parseInt(document.getElementById('targetPort').value),
                threads: parseInt(document.getElementById('threads').value),
                duration: parseInt(document.getElementById('duration').value),
                payloadSize: parseInt(document.getElementById('payloadSize').value),
                methods: methods,
                httpFlood: document.getElementById('httpFlood').checked,
                tcpFlood: document.getElementById('tcpFlood').checked,
                udpFlood: document.getElementById('udpFlood').checked,
                slowloris: document.getElementById('slowloris').checked,
                dnsAmplification: document.getElementById('dnsAmp').checked,
                memcached: document.getElementById('memcachedAmp').checked,
                ntp: document.getElementById('ntpAmp').checked,
                websocket: document.getElementById('websocketFlood').checked,
                bypassCloudflare: document.getElementById('cloudflareBypass').checked,
                randomHeaders: document.getElementById('randomHeaders').checked,
                randomPayload: document.getElementById('randomPayload').checked,
                amplification: document.getElementById('amplification').checked,
                advanced: hasAdvancedOptions
            };
        }
        
        // Start attack
        async function startAttack() {
            if (isAttacking) return;
            
            const config = getAttackConfig();
            
            if (!config.target) {
                addLogEntry('Please specify a target URL', 'error');
                showNotification('Target URL Required', 'error');
                return;
            }
            
            if (config.methods.length === 0) {
                addLogEntry('Please select at least one HTTP method', 'error');
                showNotification('HTTP Method Required', 'error');
                return;
            }
            
            isAttacking = true;
            attackStartTime = Date.now();
            
            document.getElementById('startAttack').disabled = true;
            document.getElementById('stopAttack').disabled = false;
            document.getElementById('statusIndicator').classList.remove('status-inactive');
            document.getElementById('statusIndicator').classList.add('status-active');
            
            addLogEntry(`Initializing attack on ${config.target}:${config.port}`, 'info');
            addLogEntry(`Threads: ${config.threads}, Duration: ${config.duration}s`, 'info');
            showNotification('Attack Started', 'success');
            
            try {
                const response = await fetch('/api/attack', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });
                
                const data = await response.json();
                
                if (data.id) {
                    currentAttackId = data.id;
                    addLogEntry(`Attack deployed with ID: ${data.id}`, 'info');
                    startStatusMonitoring(data.id);
                    startRealTimeMonitoring(data.id);
                } else {
                    addLogEntry('Failed to start attack', 'error');
                    showNotification('Attack Failed', 'error');
                    stopAttack();
                }
            } catch (error) {
                addLogEntry(`Failed to start attack: ${error.message}`, 'error');
                showNotification('Attack Failed', 'error');
                stopAttack();
            }
        }
        
        // Real-time monitoring function
        function startRealTimeMonitoring(attackId) {
            progressInterval = setInterval(() => {
                if (!isAttacking) return;
                
                const elapsed = (Date.now() - attackStartTime) / 1000;
                const config = getAttackConfig();
                const progress = Math.min(100, (elapsed / config.duration) * 100);
                
                document.getElementById('progressBar').style.width = `${progress}%`;
                document.getElementById('progressText').textContent = `${Math.floor(progress)}%`;
                
                if (progress >= 100) {
                    stopAttack();
                }
            }, 100);
            
            statsInterval = setInterval(() => {
                if (!isAttacking || !currentAttackId) return;
                
                fetch(`/api/attack/${currentAttackId}`)
                .then(response => response.json())
                .then(data => {
                    if (data && data.stats) {
                        updateStats(data.stats);
                    }
                })
                .catch(error => {
                    console.error('Error fetching attack status:', error);
                });
            }, 500);
        }
        
        // Stop attack
        function stopAttack() {
            if (!isAttacking) return;
            
            isAttacking = false;
            
            clearInterval(statsInterval);
            clearInterval(progressInterval);
            if (statusInterval) clearInterval(statusInterval);
            
            if (currentAttackId) {
                fetch(`/api/attack/${currentAttackId}`, { method: 'DELETE' })
                .catch(error => console.error('Error stopping attack:', error));
            }
            
            document.getElementById('startAttack').disabled = false;
            document.getElementById('stopAttack').disabled = true;
            document.getElementById('statusIndicator').classList.remove('status-active');
            document.getElementById('statusIndicator').classList.add('status-inactive');
            
            addLogEntry('Attack terminated', 'warning');
            showNotification('Attack Stopped', 'warning');
        }
        
        // Reset stats
        function resetStats() {
            updateStats({
                requests: 0,
                errors: 0,
                bytes: 0,
                rps: 0,
                successfulConnections: 0,
                failedConnections: 0
            });
            
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressText').textContent = '0%';
            
            // Reset chart data
            performanceData = {
                labels: [],
                requests: [],
                errors: [],
                rps: []
            };
            drawChart();
            
            addLogEntry('Statistics reset', 'info');
            showNotification('Stats Reset', 'info');
        }
        
        // Export configuration
        function exportConfig() {
            const config = getAttackConfig();
            const dataStr = JSON.stringify(config, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = 'xanthorox-config.json';
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            addLogEntry('Configuration exported successfully', 'info');
            showNotification('Config Exported', 'success');
        }
        
        // Import configuration
        function importConfig() {
            document.getElementById('configFile').click();
        }
        
        // Handle file selection
        document.getElementById('configFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    
                    // Apply configuration
                    document.getElementById('targetUrl').value = config.target || '';
                    document.getElementById('targetPort').value = config.port || 80;
                    document.getElementById('threads').value = config.threads || 4;
                    document.getElementById('duration').value = config.duration || 60;
                    document.getElementById('payloadSize').value = config.payloadSize || 1024;
                    
                    // Set methods
                    document.getElementById('methodGET').checked = config.methods?.includes('GET') || false;
                    document.getElementById('methodPOST').checked = config.methods?.includes('POST') || false;
                    document.getElementById('methodHEAD').checked = config.methods?.includes('HEAD') || false;
                    document.getElementById('methodOPTIONS').checked = config.methods?.includes('OPTIONS') || false;
                    document.getElementById('methodPUT').checked = config.methods?.includes('PUT') || false;
                    document.getElementById('methodDELETE').checked = config.methods?.includes('DELETE') || false;
                    document.getElementById('methodPATCH').checked = config.methods?.includes('PATCH') || false;
                    
                    // Set attack vectors
                    document.getElementById('httpFlood').checked = config.httpFlood || false;
                    document.getElementById('tcpFlood').checked = config.tcpFlood || false;
                    document.getElementById('udpFlood').checked = config.udpFlood || false;
                    document.getElementById('slowloris').checked = config.slowloris || false;
                    document.getElementById('dnsAmp').checked = config.dnsAmplification || false;
                    document.getElementById('memcachedAmp').checked = config.memcached || false;
                    document.getElementById('ntpAmp').checked = config.ntp || false;
                    document.getElementById('websocketFlood').checked = config.websocket || false;
                    
                    // Set bypass options
                    document.getElementById('cloudflareBypass').checked = config.bypassCloudflare || false;
                    document.getElementById('randomHeaders').checked = config.randomHeaders || false;
                    document.getElementById('randomPayload').checked = config.randomPayload || false;
                    document.getElementById('amplification').checked = config.amplification || false;
                    
                    addLogEntry('Configuration imported successfully', 'info');
                    showNotification('Config Imported', 'success');
                } catch (error) {
                    addLogEntry(`Failed to import configuration: ${error.message}`, 'error');
                    showNotification('Import Failed', 'error');
                }
            };
            
            reader.readAsText(file);
        });
        
        // Toggle advanced mode
        function toggleAdvancedMode() {
            addLogEntry('Advanced mode activated - All attack vectors enabled', 'info');
            showNotification('Advanced Mode Activated', 'info');
            
            // Enable all advanced options
            document.getElementById('dnsAmp').checked = true;
            document.getElementById('memcachedAmp').checked = true;
            document.getElementById('ntpAmp').checked = true;
            document.getElementById('websocketFlood').checked = true;
            
            addLogEntry('DNS Amplification: ENABLED', 'info');
            addLogEntry('Memcached Amplification: ENABLED', 'info');
            addLogEntry('NTP Amplification: ENABLED', 'info');
            addLogEntry('WebSocket Flood: ENABLED', 'info');
        }
        
        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `<i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-triangle' : 'info-circle'}"></i> ${message}`;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
    </script>
</body>
</html>